// Code generated by protoc-gen-go.
// source: golang.lakeparime.com/apis/powernode/powernode.proto
// DO NOT EDIT!

/*
Package powernode is a generated protocol buffer package.

It is generated from these files:
	golang.lakeparime.com/apis/powernode/powernode.proto

It has these top-level messages:
	PingResponse
	GRPCResponse
	CurrentState
	Hashboard
	MinerStates
	MinerState
	MinerIP
	MinerConfigResponse
	MinerConfigResponseList
	MinerConfigTemplate
	PoolConfig
	PowerMatchingPowerAlgorithmConfig
	ManualPowerAlgorithmConfig
*/
package powernode

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"
import common "golang.conradwood.net/apis/common"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

type PowerAlgorithm int32

const (
	PowerAlgorithm_UNDEFINED PowerAlgorithm = 0
	PowerAlgorithm_MATCHING  PowerAlgorithm = 1
	PowerAlgorithm_MANUAL    PowerAlgorithm = 2
)

var PowerAlgorithm_name = map[int32]string{
	0: "UNDEFINED",
	1: "MATCHING",
	2: "MANUAL",
}
var PowerAlgorithm_value = map[string]int32{
	"UNDEFINED": 0,
	"MATCHING":  1,
	"MANUAL":    2,
}

func (x PowerAlgorithm) String() string {
	return proto.EnumName(PowerAlgorithm_name, int32(x))
}
func (PowerAlgorithm) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

type HashingStatus int32

const (
	HashingStatus_UNKNOWN  HashingStatus = 0
	HashingStatus_ACTIVE   HashingStatus = 1
	HashingStatus_IDLE     HashingStatus = 2
	HashingStatus_STARTING HashingStatus = 3
	HashingStatus_ERROR    HashingStatus = 4
	HashingStatus_STOPPING HashingStatus = 5
)

var HashingStatus_name = map[int32]string{
	0: "UNKNOWN",
	1: "ACTIVE",
	2: "IDLE",
	3: "STARTING",
	4: "ERROR",
	5: "STOPPING",
}
var HashingStatus_value = map[string]int32{
	"UNKNOWN":  0,
	"ACTIVE":   1,
	"IDLE":     2,
	"STARTING": 3,
	"ERROR":    4,
	"STOPPING": 5,
}

func (x HashingStatus) String() string {
	return proto.EnumName(HashingStatus_name, int32(x))
}
func (HashingStatus) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

// comment: message pingresponse
type PingResponse struct {
	// comment: field pingresponse.response
	Response string `protobuf:"bytes,1,opt,name=Response" json:"Response,omitempty"`
}

func (m *PingResponse) Reset()                    { *m = PingResponse{} }
func (m *PingResponse) String() string            { return proto.CompactTextString(m) }
func (*PingResponse) ProtoMessage()               {}
func (*PingResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

func (m *PingResponse) GetResponse() string {
	if m != nil {
		return m.Response
	}
	return ""
}

type GRPCResponse struct {
	Success bool   `protobuf:"varint,1,opt,name=Success" json:"Success,omitempty"`
	Message string `protobuf:"bytes,2,opt,name=Message" json:"Message,omitempty"`
}

func (m *GRPCResponse) Reset()                    { *m = GRPCResponse{} }
func (m *GRPCResponse) String() string            { return proto.CompactTextString(m) }
func (*GRPCResponse) ProtoMessage()               {}
func (*GRPCResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

func (m *GRPCResponse) GetSuccess() bool {
	if m != nil {
		return m.Success
	}
	return false
}

func (m *GRPCResponse) GetMessage() string {
	if m != nil {
		return m.Message
	}
	return ""
}

// CurrentState contains all live data data about a deployment
type CurrentState struct {
	// ever increasing counter in watt hours of the power consumed by the deployment
	// For a specific meter - counter may reset on a new meter deployed
	CurrentSummationDeliveredToDeploymentWattHours float64 `protobuf:"fixed64,1,opt,name=CurrentSummationDeliveredToDeploymentWattHours" json:"CurrentSummationDeliveredToDeploymentWattHours,omitempty"`
	// how much power the deployment has consumed in past 5 seconds
	DeploymentPowerConsumedInPast5SecondsWattHours float64 `protobuf:"fixed64,2,opt,name=DeploymentPowerConsumedInPast5SecondsWattHours" json:"DeploymentPowerConsumedInPast5SecondsWattHours,omitempty"`
	// ever increasing counter in watt hours of the power generated by renewable energy source
	CurrentSummationReceivedFromPowerSourceWattHours float64 `protobuf:"fixed64,3,opt,name=CurrentSummationReceivedFromPowerSourceWattHours" json:"CurrentSummationReceivedFromPowerSourceWattHours,omitempty"`
	// how much power has been exported from power source in past 5 seconds
	PowerSourceGenerationInPast5SecondsWattHours float64 `protobuf:"fixed64,4,opt,name=PowerSourceGenerationInPast5SecondsWattHours" json:"PowerSourceGenerationInPast5SecondsWattHours,omitempty"`
	// how much power in watt hours that the deployment has drawn from the grid in past 5 seconds
	PowerImportFromGridInPast5SecondsWattHours float64 `protobuf:"fixed64,5,opt,name=PowerImportFromGridInPast5SecondsWattHours" json:"PowerImportFromGridInPast5SecondsWattHours,omitempty"`
	// the maximum amount of power in watt hours allowed to be exported to grid
	// ANM setpoint in Orkney
	ExportToGridLimitWattHours float64 `protobuf:"fixed64,6,opt,name=ExportToGridLimitWattHours" json:"ExportToGridLimitWattHours,omitempty"`
	// the amount of power in Watt Hours that could be produced by the power source
	// Potiential amount of power generated
	AvailablePowerWattHours float64 `protobuf:"fixed64,7,opt,name=AvailablePowerWattHours" json:"AvailablePowerWattHours,omitempty"`
	// the average temp in celsius of the cold isle of the deployment in past 5 seconds
	ColdIsleTempInPast5SecondsCelsius float64 `protobuf:"fixed64,8,opt,name=ColdIsleTempInPast5SecondsCelsius" json:"ColdIsleTempInPast5SecondsCelsius,omitempty"`
	// the average temp in celsius of the hot isle of the deployment in past 5 seconds
	HotIsleTempInPast5SecondsCelsius float64 `protobuf:"fixed64,9,opt,name=HotIsleTempInPast5SecondsCelsius" json:"HotIsleTempInPast5SecondsCelsius,omitempty"`
	// the number of miners in the current deployment
	DeployedMiners uint32 `protobuf:"varint,10,opt,name=DeployedMiners" json:"DeployedMiners,omitempty"`
	// the number of miners in the current deployment that are enabled / reachable
	EnabledDeployedMiners uint32 `protobuf:"varint,11,opt,name=EnabledDeployedMiners" json:"EnabledDeployedMiners,omitempty"`
	// the number of miners in the current deployment that are actively mining
	ActiveDeployedMiners uint32 `protobuf:"varint,12,opt,name=ActiveDeployedMiners" json:"ActiveDeployedMiners,omitempty"`
	// the number of miners in the current deployment that are in idle mode
	IdleDeployedMiners uint32 `protobuf:"varint,13,opt,name=IdleDeployedMiners" json:"IdleDeployedMiners,omitempty"`
	// the number of miners in the current deployment that are unreachable / disconnected
	UnreachableDeployedMiners uint32 `protobuf:"varint,14,opt,name=UnreachableDeployedMiners" json:"UnreachableDeployedMiners,omitempty"`
	// the number of target number of miners in the current deployment set by Power Node
	TargetActiveDeployedMiners uint32 `protobuf:"varint,15,opt,name=TargetActiveDeployedMiners" json:"TargetActiveDeployedMiners,omitempty"`
	// The power algorithm currently running
	PowerAlgorithm PowerAlgorithm `protobuf:"varint,16,opt,name=PowerAlgorithm,enum=powernode.PowerAlgorithm" json:"PowerAlgorithm,omitempty"`
}

func (m *CurrentState) Reset()                    { *m = CurrentState{} }
func (m *CurrentState) String() string            { return proto.CompactTextString(m) }
func (*CurrentState) ProtoMessage()               {}
func (*CurrentState) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

func (m *CurrentState) GetCurrentSummationDeliveredToDeploymentWattHours() float64 {
	if m != nil {
		return m.CurrentSummationDeliveredToDeploymentWattHours
	}
	return 0
}

func (m *CurrentState) GetDeploymentPowerConsumedInPast5SecondsWattHours() float64 {
	if m != nil {
		return m.DeploymentPowerConsumedInPast5SecondsWattHours
	}
	return 0
}

func (m *CurrentState) GetCurrentSummationReceivedFromPowerSourceWattHours() float64 {
	if m != nil {
		return m.CurrentSummationReceivedFromPowerSourceWattHours
	}
	return 0
}

func (m *CurrentState) GetPowerSourceGenerationInPast5SecondsWattHours() float64 {
	if m != nil {
		return m.PowerSourceGenerationInPast5SecondsWattHours
	}
	return 0
}

func (m *CurrentState) GetPowerImportFromGridInPast5SecondsWattHours() float64 {
	if m != nil {
		return m.PowerImportFromGridInPast5SecondsWattHours
	}
	return 0
}

func (m *CurrentState) GetExportToGridLimitWattHours() float64 {
	if m != nil {
		return m.ExportToGridLimitWattHours
	}
	return 0
}

func (m *CurrentState) GetAvailablePowerWattHours() float64 {
	if m != nil {
		return m.AvailablePowerWattHours
	}
	return 0
}

func (m *CurrentState) GetColdIsleTempInPast5SecondsCelsius() float64 {
	if m != nil {
		return m.ColdIsleTempInPast5SecondsCelsius
	}
	return 0
}

func (m *CurrentState) GetHotIsleTempInPast5SecondsCelsius() float64 {
	if m != nil {
		return m.HotIsleTempInPast5SecondsCelsius
	}
	return 0
}

func (m *CurrentState) GetDeployedMiners() uint32 {
	if m != nil {
		return m.DeployedMiners
	}
	return 0
}

func (m *CurrentState) GetEnabledDeployedMiners() uint32 {
	if m != nil {
		return m.EnabledDeployedMiners
	}
	return 0
}

func (m *CurrentState) GetActiveDeployedMiners() uint32 {
	if m != nil {
		return m.ActiveDeployedMiners
	}
	return 0
}

func (m *CurrentState) GetIdleDeployedMiners() uint32 {
	if m != nil {
		return m.IdleDeployedMiners
	}
	return 0
}

func (m *CurrentState) GetUnreachableDeployedMiners() uint32 {
	if m != nil {
		return m.UnreachableDeployedMiners
	}
	return 0
}

func (m *CurrentState) GetTargetActiveDeployedMiners() uint32 {
	if m != nil {
		return m.TargetActiveDeployedMiners
	}
	return 0
}

func (m *CurrentState) GetPowerAlgorithm() PowerAlgorithm {
	if m != nil {
		return m.PowerAlgorithm
	}
	return PowerAlgorithm_UNDEFINED
}

type Hashboard struct {
	// returns a list of the values of the temp sensors in celsius
	TempSensorsInCelsius []float64 `protobuf:"fixed64,1,rep,packed,name=TempSensorsInCelsius" json:"TempSensorsInCelsius,omitempty"`
	// returns the current voltage supplied to the hashboard
	Voltage float64 `protobuf:"fixed64,2,opt,name=Voltage" json:"Voltage,omitempty"`
	// returns the X-average frequency in Hertz
	FrequencyInHertz float64 `protobuf:"fixed64,3,opt,name=FrequencyInHertz" json:"FrequencyInHertz,omitempty"`
	// returns the theoretical max hashrate this hashboard can produce (Hashes/s)
	IdealHashrateHashesPerSecond float64 `protobuf:"fixed64,4,opt,name=IdealHashrateHashesPerSecond" json:"IdealHashrateHashesPerSecond,omitempty"`
	// returns the 5 second average hashrate in Hashes/s
	Hashrate5SecAverageHashesPerSecond float64 `protobuf:"fixed64,5,opt,name=Hashrate5SecAverageHashesPerSecond" json:"Hashrate5SecAverageHashesPerSecond,omitempty"`
	// ID field to identify between hashboards on the same miner
	ID uint32 `protobuf:"varint,6,opt,name=ID" json:"ID,omitempty"`
}

func (m *Hashboard) Reset()                    { *m = Hashboard{} }
func (m *Hashboard) String() string            { return proto.CompactTextString(m) }
func (*Hashboard) ProtoMessage()               {}
func (*Hashboard) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

func (m *Hashboard) GetTempSensorsInCelsius() []float64 {
	if m != nil {
		return m.TempSensorsInCelsius
	}
	return nil
}

func (m *Hashboard) GetVoltage() float64 {
	if m != nil {
		return m.Voltage
	}
	return 0
}

func (m *Hashboard) GetFrequencyInHertz() float64 {
	if m != nil {
		return m.FrequencyInHertz
	}
	return 0
}

func (m *Hashboard) GetIdealHashrateHashesPerSecond() float64 {
	if m != nil {
		return m.IdealHashrateHashesPerSecond
	}
	return 0
}

func (m *Hashboard) GetHashrate5SecAverageHashesPerSecond() float64 {
	if m != nil {
		return m.Hashrate5SecAverageHashesPerSecond
	}
	return 0
}

func (m *Hashboard) GetID() uint32 {
	if m != nil {
		return m.ID
	}
	return 0
}

type MinerStates struct {
	// Returns a repeated list of miners
	MinerStates []*MinerState `protobuf:"bytes,1,rep,name=MinerStates" json:"MinerStates,omitempty"`
}

func (m *MinerStates) Reset()                    { *m = MinerStates{} }
func (m *MinerStates) String() string            { return proto.CompactTextString(m) }
func (*MinerStates) ProtoMessage()               {}
func (*MinerStates) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{4} }

func (m *MinerStates) GetMinerStates() []*MinerState {
	if m != nil {
		return m.MinerStates
	}
	return nil
}

type MinerState struct {
	// Returns true if the device is on, false if it is off / unreachable
	DeviceStatus bool `protobuf:"varint,1,opt,name=DeviceStatus" json:"DeviceStatus,omitempty"`
	// Unix timestamp of when the query started
	UnixTimestamp uint64 `protobuf:"varint,2,opt,name=UnixTimestamp" json:"UnixTimestamp,omitempty"`
	// returns an enum based on hashing status on the miner
	HashingStatus HashingStatus `protobuf:"varint,3,opt,name=HashingStatus,enum=powernode.HashingStatus" json:"HashingStatus,omitempty"`
	// returns an enum based on the desired hashing status set by PowerNode
	DesiredHashingStatus HashingStatus `protobuf:"varint,4,opt,name=DesiredHashingStatus,enum=powernode.HashingStatus" json:"DesiredHashingStatus,omitempty"`
	// returns the 5 second average hashrate for the miner (Hashes/s)
	Hashrate5SecAverageHashesPerSecond float64 `protobuf:"fixed64,5,opt,name=Hashrate5SecAverageHashesPerSecond" json:"Hashrate5SecAverageHashesPerSecond,omitempty"`
	// returns the uptime of the miner, in seconds.
	// Uptime of CGMiner
	CGMinerUptimeInSeconds int32 `protobuf:"varint,6,opt,name=CGMinerUptimeInSeconds" json:"CGMinerUptimeInSeconds,omitempty"`
	// returns data about each specific hashboard on the miner
	Hashboards []*Hashboard `protobuf:"bytes,7,rep,name=Hashboards" json:"Hashboards,omitempty"`
	// returns the potential total max hashrate for whole miner (GH/s)
	IdealHashrateHashesPerSecond float64 `protobuf:"fixed64,8,opt,name=IdealHashrateHashesPerSecond" json:"IdealHashrateHashesPerSecond,omitempty"`
	// returns the average frequency from all hashboards (Hertz)
	AverageFrequencyHertz float64 `protobuf:"fixed64,9,opt,name=AverageFrequencyHertz" json:"AverageFrequencyHertz,omitempty"`
	// returns the pool url used by the miner
	PoolURL string `protobuf:"bytes,10,opt,name=PoolURL" json:"PoolURL,omitempty"`
	// returns the IPAddress of the miner
	MinerIPAddress *MinerIP `protobuf:"bytes,13,opt,name=MinerIPAddress" json:"MinerIPAddress,omitempty"`
}

func (m *MinerState) Reset()                    { *m = MinerState{} }
func (m *MinerState) String() string            { return proto.CompactTextString(m) }
func (*MinerState) ProtoMessage()               {}
func (*MinerState) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{5} }

func (m *MinerState) GetDeviceStatus() bool {
	if m != nil {
		return m.DeviceStatus
	}
	return false
}

func (m *MinerState) GetUnixTimestamp() uint64 {
	if m != nil {
		return m.UnixTimestamp
	}
	return 0
}

func (m *MinerState) GetHashingStatus() HashingStatus {
	if m != nil {
		return m.HashingStatus
	}
	return HashingStatus_UNKNOWN
}

func (m *MinerState) GetDesiredHashingStatus() HashingStatus {
	if m != nil {
		return m.DesiredHashingStatus
	}
	return HashingStatus_UNKNOWN
}

func (m *MinerState) GetHashrate5SecAverageHashesPerSecond() float64 {
	if m != nil {
		return m.Hashrate5SecAverageHashesPerSecond
	}
	return 0
}

func (m *MinerState) GetCGMinerUptimeInSeconds() int32 {
	if m != nil {
		return m.CGMinerUptimeInSeconds
	}
	return 0
}

func (m *MinerState) GetHashboards() []*Hashboard {
	if m != nil {
		return m.Hashboards
	}
	return nil
}

func (m *MinerState) GetIdealHashrateHashesPerSecond() float64 {
	if m != nil {
		return m.IdealHashrateHashesPerSecond
	}
	return 0
}

func (m *MinerState) GetAverageFrequencyHertz() float64 {
	if m != nil {
		return m.AverageFrequencyHertz
	}
	return 0
}

func (m *MinerState) GetPoolURL() string {
	if m != nil {
		return m.PoolURL
	}
	return ""
}

func (m *MinerState) GetMinerIPAddress() *MinerIP {
	if m != nil {
		return m.MinerIPAddress
	}
	return nil
}

type MinerIP struct {
	// Returns the IPAddress of a miner
	IPAddress string `protobuf:"bytes,1,opt,name=IPAddress" json:"IPAddress,omitempty"`
}

func (m *MinerIP) Reset()                    { *m = MinerIP{} }
func (m *MinerIP) String() string            { return proto.CompactTextString(m) }
func (*MinerIP) ProtoMessage()               {}
func (*MinerIP) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{6} }

func (m *MinerIP) GetIPAddress() string {
	if m != nil {
		return m.IPAddress
	}
	return ""
}

type MinerConfigResponse struct {
	// Response sent back by miners when changing their configuration
	MinerIP *MinerIP `protobuf:"bytes,1,opt,name=MinerIP" json:"MinerIP,omitempty"`
	Status  bool     `protobuf:"varint,2,opt,name=Status" json:"Status,omitempty"`
}

func (m *MinerConfigResponse) Reset()                    { *m = MinerConfigResponse{} }
func (m *MinerConfigResponse) String() string            { return proto.CompactTextString(m) }
func (*MinerConfigResponse) ProtoMessage()               {}
func (*MinerConfigResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{7} }

func (m *MinerConfigResponse) GetMinerIP() *MinerIP {
	if m != nil {
		return m.MinerIP
	}
	return nil
}

func (m *MinerConfigResponse) GetStatus() bool {
	if m != nil {
		return m.Status
	}
	return false
}

type MinerConfigResponseList struct {
	Responses []*MinerConfigResponse `protobuf:"bytes,1,rep,name=Responses" json:"Responses,omitempty"`
}

func (m *MinerConfigResponseList) Reset()                    { *m = MinerConfigResponseList{} }
func (m *MinerConfigResponseList) String() string            { return proto.CompactTextString(m) }
func (*MinerConfigResponseList) ProtoMessage()               {}
func (*MinerConfigResponseList) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{8} }

func (m *MinerConfigResponseList) GetResponses() []*MinerConfigResponse {
	if m != nil {
		return m.Responses
	}
	return nil
}

type MinerConfigTemplate struct {
	// The list of miners that this config should apply to
	MinerIPs []*MinerIP `protobuf:"bytes,1,rep,name=MinerIPs" json:"MinerIPs,omitempty"`
	// Templates for the default pool url, user and pass
	// Template info can be found in README
	PoolConfigs []*PoolConfig `protobuf:"bytes,2,rep,name=PoolConfigs" json:"PoolConfigs,omitempty"`
	// enables or disables the CGMiner API
	APIAllow bool `protobuf:"varint,3,opt,name=APIAllow" json:"APIAllow,omitempty"`
	// The port is to specify which port the miner rpc api is enabled on
	APIPort uint32 `protobuf:"varint,4,opt,name=APIPort" json:"APIPort,omitempty"`
}

func (m *MinerConfigTemplate) Reset()                    { *m = MinerConfigTemplate{} }
func (m *MinerConfigTemplate) String() string            { return proto.CompactTextString(m) }
func (*MinerConfigTemplate) ProtoMessage()               {}
func (*MinerConfigTemplate) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{9} }

func (m *MinerConfigTemplate) GetMinerIPs() []*MinerIP {
	if m != nil {
		return m.MinerIPs
	}
	return nil
}

func (m *MinerConfigTemplate) GetPoolConfigs() []*PoolConfig {
	if m != nil {
		return m.PoolConfigs
	}
	return nil
}

func (m *MinerConfigTemplate) GetAPIAllow() bool {
	if m != nil {
		return m.APIAllow
	}
	return false
}

func (m *MinerConfigTemplate) GetAPIPort() uint32 {
	if m != nil {
		return m.APIPort
	}
	return 0
}

type PoolConfig struct {
	// Templates for the default pool url, user and pass
	// Template info can be found in README
	PoolURL      string `protobuf:"bytes,1,opt,name=PoolURL" json:"PoolURL,omitempty"`
	PoolUsername string `protobuf:"bytes,2,opt,name=PoolUsername" json:"PoolUsername,omitempty"`
	PoolPassword string `protobuf:"bytes,3,opt,name=PoolPassword" json:"PoolPassword,omitempty"`
}

func (m *PoolConfig) Reset()                    { *m = PoolConfig{} }
func (m *PoolConfig) String() string            { return proto.CompactTextString(m) }
func (*PoolConfig) ProtoMessage()               {}
func (*PoolConfig) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{10} }

func (m *PoolConfig) GetPoolURL() string {
	if m != nil {
		return m.PoolURL
	}
	return ""
}

func (m *PoolConfig) GetPoolUsername() string {
	if m != nil {
		return m.PoolUsername
	}
	return ""
}

func (m *PoolConfig) GetPoolPassword() string {
	if m != nil {
		return m.PoolPassword
	}
	return ""
}

type PowerMatchingPowerAlgorithmConfig struct {
	// The margin to be used when determining the max power draw
	SafteyMargin float64 `protobuf:"fixed64,1,opt,name=SafteyMargin" json:"SafteyMargin,omitempty"`
	// The difference between two power setpoints that the HPCs should react to
	ReactionDifferenceThreshold float64 `protobuf:"fixed64,2,opt,name=ReactionDifferenceThreshold" json:"ReactionDifferenceThreshold,omitempty"`
}

func (m *PowerMatchingPowerAlgorithmConfig) Reset()         { *m = PowerMatchingPowerAlgorithmConfig{} }
func (m *PowerMatchingPowerAlgorithmConfig) String() string { return proto.CompactTextString(m) }
func (*PowerMatchingPowerAlgorithmConfig) ProtoMessage()    {}
func (*PowerMatchingPowerAlgorithmConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor0, []int{11}
}

func (m *PowerMatchingPowerAlgorithmConfig) GetSafteyMargin() float64 {
	if m != nil {
		return m.SafteyMargin
	}
	return 0
}

func (m *PowerMatchingPowerAlgorithmConfig) GetReactionDifferenceThreshold() float64 {
	if m != nil {
		return m.ReactionDifferenceThreshold
	}
	return 0
}

type ManualPowerAlgorithmConfig struct {
	// Set the amount of power the deployment should use
	PowerSetpointWatts float64 `protobuf:"fixed64,1,opt,name=PowerSetpointWatts" json:"PowerSetpointWatts,omitempty"`
}

func (m *ManualPowerAlgorithmConfig) Reset()                    { *m = ManualPowerAlgorithmConfig{} }
func (m *ManualPowerAlgorithmConfig) String() string            { return proto.CompactTextString(m) }
func (*ManualPowerAlgorithmConfig) ProtoMessage()               {}
func (*ManualPowerAlgorithmConfig) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{12} }

func (m *ManualPowerAlgorithmConfig) GetPowerSetpointWatts() float64 {
	if m != nil {
		return m.PowerSetpointWatts
	}
	return 0
}

func init() {
	proto.RegisterType((*PingResponse)(nil), "powernode.PingResponse")
	proto.RegisterType((*GRPCResponse)(nil), "powernode.GRPCResponse")
	proto.RegisterType((*CurrentState)(nil), "powernode.CurrentState")
	proto.RegisterType((*Hashboard)(nil), "powernode.Hashboard")
	proto.RegisterType((*MinerStates)(nil), "powernode.MinerStates")
	proto.RegisterType((*MinerState)(nil), "powernode.MinerState")
	proto.RegisterType((*MinerIP)(nil), "powernode.MinerIP")
	proto.RegisterType((*MinerConfigResponse)(nil), "powernode.MinerConfigResponse")
	proto.RegisterType((*MinerConfigResponseList)(nil), "powernode.MinerConfigResponseList")
	proto.RegisterType((*MinerConfigTemplate)(nil), "powernode.MinerConfigTemplate")
	proto.RegisterType((*PoolConfig)(nil), "powernode.PoolConfig")
	proto.RegisterType((*PowerMatchingPowerAlgorithmConfig)(nil), "powernode.PowerMatchingPowerAlgorithmConfig")
	proto.RegisterType((*ManualPowerAlgorithmConfig)(nil), "powernode.ManualPowerAlgorithmConfig")
	proto.RegisterEnum("powernode.PowerAlgorithm", PowerAlgorithm_name, PowerAlgorithm_value)
	proto.RegisterEnum("powernode.HashingStatus", HashingStatus_name, HashingStatus_value)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for PowerNode service

type PowerNodeClient interface {
	// example rpc
	Ping(ctx context.Context, in *common.Void, opts ...grpc.CallOption) (*PingResponse, error)
	// return information about powernode's state
	GetCurrentState(ctx context.Context, in *common.Void, opts ...grpc.CallOption) (*CurrentState, error)
	// return information about Miners
	GetMinerStates(ctx context.Context, in *common.Void, opts ...grpc.CallOption) (*MinerStates, error)
	// set the current power algorithm to manual mode
	EnableManualPowerAlgorithm(ctx context.Context, in *ManualPowerAlgorithmConfig, opts ...grpc.CallOption) (*GRPCResponse, error)
	// set the current power algorithm to power matching mode
	EnablePowerMatchingPowerAlgorithm(ctx context.Context, in *PowerMatchingPowerAlgorithmConfig, opts ...grpc.CallOption) (*GRPCResponse, error)
	// using a list of miner IPs, sets their configs to match a template
	SetMinerConfigTemplate(ctx context.Context, in *MinerConfigTemplate, opts ...grpc.CallOption) (*MinerConfigResponseList, error)
	// Enable this copy of PowerNode
	EnablePowerNode(ctx context.Context, in *common.Void, opts ...grpc.CallOption) (*GRPCResponse, error)
	// Disable this copy of PowerNode
	DisablePowerNode(ctx context.Context, in *common.Void, opts ...grpc.CallOption) (*GRPCResponse, error)
}

type powerNodeClient struct {
	cc *grpc.ClientConn
}

func NewPowerNodeClient(cc *grpc.ClientConn) PowerNodeClient {
	return &powerNodeClient{cc}
}

func (c *powerNodeClient) Ping(ctx context.Context, in *common.Void, opts ...grpc.CallOption) (*PingResponse, error) {
	out := new(PingResponse)
	err := grpc.Invoke(ctx, "/powernode.PowerNode/Ping", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *powerNodeClient) GetCurrentState(ctx context.Context, in *common.Void, opts ...grpc.CallOption) (*CurrentState, error) {
	out := new(CurrentState)
	err := grpc.Invoke(ctx, "/powernode.PowerNode/GetCurrentState", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *powerNodeClient) GetMinerStates(ctx context.Context, in *common.Void, opts ...grpc.CallOption) (*MinerStates, error) {
	out := new(MinerStates)
	err := grpc.Invoke(ctx, "/powernode.PowerNode/GetMinerStates", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *powerNodeClient) EnableManualPowerAlgorithm(ctx context.Context, in *ManualPowerAlgorithmConfig, opts ...grpc.CallOption) (*GRPCResponse, error) {
	out := new(GRPCResponse)
	err := grpc.Invoke(ctx, "/powernode.PowerNode/EnableManualPowerAlgorithm", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *powerNodeClient) EnablePowerMatchingPowerAlgorithm(ctx context.Context, in *PowerMatchingPowerAlgorithmConfig, opts ...grpc.CallOption) (*GRPCResponse, error) {
	out := new(GRPCResponse)
	err := grpc.Invoke(ctx, "/powernode.PowerNode/EnablePowerMatchingPowerAlgorithm", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *powerNodeClient) SetMinerConfigTemplate(ctx context.Context, in *MinerConfigTemplate, opts ...grpc.CallOption) (*MinerConfigResponseList, error) {
	out := new(MinerConfigResponseList)
	err := grpc.Invoke(ctx, "/powernode.PowerNode/SetMinerConfigTemplate", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *powerNodeClient) EnablePowerNode(ctx context.Context, in *common.Void, opts ...grpc.CallOption) (*GRPCResponse, error) {
	out := new(GRPCResponse)
	err := grpc.Invoke(ctx, "/powernode.PowerNode/EnablePowerNode", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *powerNodeClient) DisablePowerNode(ctx context.Context, in *common.Void, opts ...grpc.CallOption) (*GRPCResponse, error) {
	out := new(GRPCResponse)
	err := grpc.Invoke(ctx, "/powernode.PowerNode/DisablePowerNode", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for PowerNode service

type PowerNodeServer interface {
	// example rpc
	Ping(context.Context, *common.Void) (*PingResponse, error)
	// return information about powernode's state
	GetCurrentState(context.Context, *common.Void) (*CurrentState, error)
	// return information about Miners
	GetMinerStates(context.Context, *common.Void) (*MinerStates, error)
	// set the current power algorithm to manual mode
	EnableManualPowerAlgorithm(context.Context, *ManualPowerAlgorithmConfig) (*GRPCResponse, error)
	// set the current power algorithm to power matching mode
	EnablePowerMatchingPowerAlgorithm(context.Context, *PowerMatchingPowerAlgorithmConfig) (*GRPCResponse, error)
	// using a list of miner IPs, sets their configs to match a template
	SetMinerConfigTemplate(context.Context, *MinerConfigTemplate) (*MinerConfigResponseList, error)
	// Enable this copy of PowerNode
	EnablePowerNode(context.Context, *common.Void) (*GRPCResponse, error)
	// Disable this copy of PowerNode
	DisablePowerNode(context.Context, *common.Void) (*GRPCResponse, error)
}

func RegisterPowerNodeServer(s *grpc.Server, srv PowerNodeServer) {
	s.RegisterService(&_PowerNode_serviceDesc, srv)
}

func _PowerNode_Ping_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(common.Void)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PowerNodeServer).Ping(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/powernode.PowerNode/Ping",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PowerNodeServer).Ping(ctx, req.(*common.Void))
	}
	return interceptor(ctx, in, info, handler)
}

func _PowerNode_GetCurrentState_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(common.Void)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PowerNodeServer).GetCurrentState(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/powernode.PowerNode/GetCurrentState",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PowerNodeServer).GetCurrentState(ctx, req.(*common.Void))
	}
	return interceptor(ctx, in, info, handler)
}

func _PowerNode_GetMinerStates_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(common.Void)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PowerNodeServer).GetMinerStates(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/powernode.PowerNode/GetMinerStates",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PowerNodeServer).GetMinerStates(ctx, req.(*common.Void))
	}
	return interceptor(ctx, in, info, handler)
}

func _PowerNode_EnableManualPowerAlgorithm_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ManualPowerAlgorithmConfig)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PowerNodeServer).EnableManualPowerAlgorithm(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/powernode.PowerNode/EnableManualPowerAlgorithm",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PowerNodeServer).EnableManualPowerAlgorithm(ctx, req.(*ManualPowerAlgorithmConfig))
	}
	return interceptor(ctx, in, info, handler)
}

func _PowerNode_EnablePowerMatchingPowerAlgorithm_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PowerMatchingPowerAlgorithmConfig)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PowerNodeServer).EnablePowerMatchingPowerAlgorithm(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/powernode.PowerNode/EnablePowerMatchingPowerAlgorithm",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PowerNodeServer).EnablePowerMatchingPowerAlgorithm(ctx, req.(*PowerMatchingPowerAlgorithmConfig))
	}
	return interceptor(ctx, in, info, handler)
}

func _PowerNode_SetMinerConfigTemplate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MinerConfigTemplate)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PowerNodeServer).SetMinerConfigTemplate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/powernode.PowerNode/SetMinerConfigTemplate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PowerNodeServer).SetMinerConfigTemplate(ctx, req.(*MinerConfigTemplate))
	}
	return interceptor(ctx, in, info, handler)
}

func _PowerNode_EnablePowerNode_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(common.Void)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PowerNodeServer).EnablePowerNode(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/powernode.PowerNode/EnablePowerNode",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PowerNodeServer).EnablePowerNode(ctx, req.(*common.Void))
	}
	return interceptor(ctx, in, info, handler)
}

func _PowerNode_DisablePowerNode_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(common.Void)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PowerNodeServer).DisablePowerNode(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/powernode.PowerNode/DisablePowerNode",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PowerNodeServer).DisablePowerNode(ctx, req.(*common.Void))
	}
	return interceptor(ctx, in, info, handler)
}

var _PowerNode_serviceDesc = grpc.ServiceDesc{
	ServiceName: "powernode.PowerNode",
	HandlerType: (*PowerNodeServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Ping",
			Handler:    _PowerNode_Ping_Handler,
		},
		{
			MethodName: "GetCurrentState",
			Handler:    _PowerNode_GetCurrentState_Handler,
		},
		{
			MethodName: "GetMinerStates",
			Handler:    _PowerNode_GetMinerStates_Handler,
		},
		{
			MethodName: "EnableManualPowerAlgorithm",
			Handler:    _PowerNode_EnableManualPowerAlgorithm_Handler,
		},
		{
			MethodName: "EnablePowerMatchingPowerAlgorithm",
			Handler:    _PowerNode_EnablePowerMatchingPowerAlgorithm_Handler,
		},
		{
			MethodName: "SetMinerConfigTemplate",
			Handler:    _PowerNode_SetMinerConfigTemplate_Handler,
		},
		{
			MethodName: "EnablePowerNode",
			Handler:    _PowerNode_EnablePowerNode_Handler,
		},
		{
			MethodName: "DisablePowerNode",
			Handler:    _PowerNode_DisablePowerNode_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "golang.lakeparime.com/apis/powernode/powernode.proto",
}

func init() {
	proto.RegisterFile("golang.lakeparime.com/apis/powernode/powernode.proto", fileDescriptor0)
}

var fileDescriptor0 = []byte{
	// 1366 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x09, 0x6e, 0x88, 0x02, 0xff, 0xac, 0x57, 0xef, 0x6e, 0xdb, 0x46,
	0x12, 0x8f, 0x64, 0xd9, 0x96, 0xc6, 0xb2, 0x23, 0xec, 0x25, 0x8e, 0xe3, 0xcb, 0xdd, 0x39, 0xc4,
	0xb5, 0x35, 0x8c, 0x54, 0x29, 0x5c, 0x37, 0x4d, 0x8a, 0x20, 0xa8, 0x22, 0xf9, 0x0f, 0x5b, 0x59,
	0x11, 0x56, 0x72, 0x82, 0xa2, 0x41, 0x81, 0x35, 0x39, 0x96, 0x99, 0x92, 0xbb, 0xea, 0x2e, 0x65,
	0x27, 0x7d, 0x83, 0x3e, 0x48, 0x3f, 0xf4, 0x7b, 0x5f, 0xa2, 0xaf, 0xd3, 0x27, 0x28, 0x76, 0x49,
	0x8a, 0x22, 0x23, 0xc9, 0x71, 0xd1, 0x4f, 0xd2, 0xec, 0xfc, 0x7e, 0x33, 0xc3, 0x9d, 0xd9, 0xd9,
	0x59, 0xd8, 0x1b, 0x08, 0x9f, 0xf1, 0x41, 0xdd, 0x67, 0x3f, 0xe2, 0x90, 0x49, 0x2f, 0xc0, 0xba,
	0x23, 0x82, 0x87, 0x6c, 0xe8, 0xa9, 0x87, 0x43, 0x71, 0x89, 0x92, 0x0b, 0x17, 0xd3, 0x7f, 0xf5,
	0xa1, 0x14, 0xa1, 0x20, 0x95, 0xf1, 0xc2, 0x66, 0x3d, 0x36, 0xe0, 0x08, 0x2e, 0x99, 0x7b, 0x29,
	0x84, 0x5b, 0xe7, 0x18, 0x46, 0x06, 0x1c, 0x11, 0x04, 0x82, 0xc7, 0x3f, 0x11, 0xd5, 0xda, 0x81,
	0x6a, 0xd7, 0xe3, 0x03, 0x8a, 0x6a, 0x28, 0xb8, 0x42, 0xb2, 0x09, 0xe5, 0xe4, 0xff, 0x46, 0x61,
	0xab, 0xb0, 0x5d, 0xa1, 0x63, 0xd9, 0x7a, 0x0e, 0xd5, 0x43, 0xda, 0x6d, 0x8e, 0xb1, 0x1b, 0xb0,
	0xdc, 0x1b, 0x39, 0x0e, 0x2a, 0x65, 0xa0, 0x65, 0x9a, 0x88, 0x5a, 0x73, 0x8c, 0x4a, 0xb1, 0x01,
	0x6e, 0x14, 0x8d, 0x91, 0x44, 0xb4, 0x7e, 0xad, 0x40, 0xb5, 0x39, 0x92, 0x12, 0x79, 0xd8, 0x0b,
	0x59, 0x88, 0xe4, 0x0c, 0xea, 0x89, 0x3c, 0x0a, 0x02, 0x16, 0x7a, 0x82, 0xb7, 0xd0, 0xf7, 0x2e,
	0x50, 0xa2, 0xdb, 0x17, 0x2d, 0x1c, 0xfa, 0xe2, 0x5d, 0x80, 0x3c, 0x7c, 0xc5, 0xc2, 0xf0, 0x48,
	0x8c, 0x64, 0xe4, 0xab, 0x40, 0xaf, 0xc9, 0xd2, 0x7e, 0xd2, 0xe5, 0xae, 0xde, 0xaf, 0xa6, 0xe0,
	0x6a, 0x14, 0xa0, 0x6b, 0xf3, 0x2e, 0x53, 0xe1, 0x17, 0x3d, 0x74, 0x04, 0x77, 0x55, 0xea, 0xa7,
	0x18, 0xf9, 0xb9, 0x1e, 0x8b, 0xbc, 0x81, 0xcf, 0xf2, 0x91, 0x51, 0x74, 0xd0, 0xbb, 0x40, 0xf7,
	0x40, 0x8a, 0xc0, 0xd8, 0xe8, 0x89, 0x91, 0x74, 0x30, 0xf5, 0xb4, 0x60, 0x3c, 0x5d, 0x9b, 0x47,
	0x4e, 0xe1, 0xc1, 0xc4, 0xfa, 0x21, 0x72, 0x94, 0x86, 0x38, 0xeb, 0x8b, 0x4a, 0xc6, 0xcf, 0xb5,
	0x38, 0xe4, 0x07, 0xd8, 0x31, 0x78, 0x3b, 0x18, 0x0a, 0x19, 0xea, 0x50, 0x0e, 0xa5, 0x37, 0x73,
	0xcf, 0x16, 0x8d, 0x87, 0x6b, 0x30, 0xc8, 0x33, 0xd8, 0xdc, 0x7f, 0xab, 0x81, 0x7d, 0xa1, 0x61,
	0x6d, 0x2f, 0xf0, 0x26, 0x72, 0xbd, 0x64, 0xec, 0xcd, 0x41, 0x90, 0xc7, 0x70, 0xa7, 0x71, 0xc1,
	0x3c, 0x9f, 0x9d, 0xfa, 0x68, 0xdc, 0xa6, 0xe4, 0x65, 0x43, 0x9e, 0xa5, 0x26, 0x6d, 0xb8, 0xdf,
	0x14, 0xbe, 0x6b, 0x2b, 0x1f, 0xfb, 0x18, 0x0c, 0xb3, 0x01, 0x36, 0xd1, 0x57, 0xde, 0x48, 0x6d,
	0x94, 0x8d, 0x8d, 0xab, 0x81, 0xe4, 0x1b, 0xd8, 0x3a, 0x12, 0xe1, 0x7c, 0x63, 0x15, 0x63, 0xec,
	0x4a, 0x1c, 0xf9, 0x18, 0xd6, 0xa2, 0xaa, 0x43, 0xf7, 0xd8, 0xe3, 0x28, 0xd5, 0x06, 0x6c, 0x15,
	0xb6, 0x57, 0x69, 0x6e, 0x95, 0xec, 0xc1, 0xed, 0x7d, 0xae, 0xbf, 0xcc, 0xcd, 0xc1, 0x57, 0x0c,
	0x7c, 0xba, 0x92, 0xec, 0xc2, 0xad, 0x86, 0x13, 0x7a, 0x17, 0x98, 0x23, 0x55, 0x0d, 0x69, 0xaa,
	0x8e, 0xd4, 0x81, 0xd8, 0xae, 0x9f, 0x67, 0xac, 0x1a, 0xc6, 0x14, 0x0d, 0x79, 0x0a, 0x77, 0x4f,
	0xb8, 0x44, 0xe6, 0x9c, 0xeb, 0x08, 0x72, 0xb4, 0x35, 0x43, 0x9b, 0x0d, 0xd0, 0x35, 0xd1, 0x67,
	0x72, 0x80, 0xe1, 0xd4, 0x38, 0x6f, 0x1a, 0xfa, 0x1c, 0x04, 0x69, 0xc0, 0x9a, 0xc9, 0x75, 0xc3,
	0x1f, 0x08, 0xe9, 0x85, 0xe7, 0xc1, 0x46, 0x6d, 0xab, 0xb0, 0xbd, 0xb6, 0x7b, 0xb7, 0x9e, 0x76,
	0xce, 0x2c, 0x80, 0xe6, 0x08, 0xd6, 0x6f, 0x45, 0xa8, 0x1c, 0x31, 0x75, 0x7e, 0x2a, 0x98, 0x74,
	0xf5, 0x96, 0xe9, 0x6c, 0xf5, 0x90, 0x2b, 0x21, 0x95, 0xcd, 0x93, 0x84, 0x16, 0xb6, 0x16, 0xb6,
	0x0b, 0x74, 0xaa, 0x4e, 0xf7, 0xc0, 0x97, 0xc2, 0x0f, 0x93, 0x1e, 0x58, 0xa0, 0x89, 0x48, 0x76,
	0xa0, 0x76, 0x20, 0xf1, 0xa7, 0x11, 0x72, 0xe7, 0x9d, 0xcd, 0x8f, 0x50, 0x86, 0x3f, 0xc7, 0x2d,
	0xe0, 0xbd, 0x75, 0xf2, 0x1c, 0xee, 0xd9, 0x2e, 0x32, 0x5f, 0xc7, 0x22, 0x59, 0x88, 0xfa, 0x17,
	0x55, 0x17, 0x65, 0x54, 0x32, 0xf1, 0x91, 0x9e, 0x8b, 0x21, 0x1d, 0xb0, 0x12, 0x95, 0xae, 0xb4,
	0xc6, 0x05, 0x4a, 0x36, 0x78, 0xcf, 0x52, 0x74, 0x74, 0x3f, 0x00, 0x49, 0xd6, 0xa0, 0x68, 0xb7,
	0xcc, 0xd1, 0x5c, 0xa5, 0x45, 0xbb, 0x65, 0x1d, 0xc0, 0x8a, 0xd9, 0x78, 0xd3, 0xd0, 0x15, 0xf9,
	0x32, 0x23, 0x9a, 0x3d, 0x5a, 0xd9, 0xbd, 0x3d, 0xb1, 0xf5, 0xa9, 0x96, 0x4e, 0x22, 0xad, 0x3f,
	0x4b, 0x00, 0xa9, 0x4c, 0x2c, 0xa8, 0xb6, 0xf0, 0xc2, 0x73, 0x50, 0x8b, 0xa3, 0xe4, 0x8e, 0xc9,
	0xac, 0x91, 0xff, 0xc3, 0xea, 0x09, 0xf7, 0xde, 0xf6, 0xbd, 0x00, 0x55, 0xc8, 0x82, 0xa1, 0xd9,
	0xea, 0x12, 0xcd, 0x2e, 0x92, 0x67, 0xb0, 0xaa, 0xbf, 0xc1, 0xe3, 0x83, 0xd8, 0xd4, 0x82, 0x29,
	0x87, 0x8d, 0x89, 0x98, 0x32, 0x7a, 0x9a, 0x85, 0x93, 0x36, 0xdc, 0x6a, 0xa1, 0xf2, 0x24, 0xba,
	0x59, 0x33, 0xa5, 0x2b, 0xcc, 0x4c, 0x65, 0xfd, 0xe3, 0xe9, 0x78, 0x04, 0xeb, 0xcd, 0x43, 0xb3,
	0x6f, 0x27, 0xc3, 0xd0, 0x0b, 0xd0, 0xe6, 0x71, 0x3b, 0x31, 0x29, 0x5a, 0xa4, 0x33, 0xb4, 0x64,
	0x0f, 0x60, 0x5c, 0xe1, 0xba, 0x59, 0xea, 0x34, 0xdd, 0xca, 0x7d, 0x8b, 0x51, 0xd2, 0x09, 0xdc,
	0x95, 0x05, 0x59, 0xfe, 0x80, 0x82, 0xdc, 0x83, 0xdb, 0xf1, 0xb7, 0x8c, 0xeb, 0x3d, 0x3a, 0x05,
	0x51, 0x83, 0x9c, 0xae, 0xd4, 0x07, 0xaa, 0x2b, 0x84, 0x7f, 0x42, 0xdb, 0xa6, 0x1d, 0x56, 0x68,
	0x22, 0x92, 0xaf, 0x60, 0xcd, 0x7c, 0xa1, 0xdd, 0x6d, 0xb8, 0xae, 0xd4, 0xf3, 0x88, 0xee, 0x4c,
	0x2b, 0xbb, 0x24, 0x5f, 0x74, 0x76, 0x97, 0xe6, 0x90, 0xd6, 0x27, 0xb0, 0x1c, 0xaf, 0x90, 0x7b,
	0x50, 0x49, 0x2d, 0x44, 0xc3, 0x4f, 0xba, 0x60, 0x7d, 0x0f, 0xff, 0x32, 0xc0, 0xa6, 0xe0, 0x67,
	0x5e, 0x3a, 0x30, 0x3d, 0x18, 0xf3, 0x0d, 0x65, 0xba, 0xd3, 0xb1, 0x8b, 0x75, 0x58, 0x8a, 0x6b,
	0xa7, 0x68, 0xaa, 0x39, 0x96, 0xac, 0x57, 0x70, 0x67, 0x8a, 0xf1, 0xb6, 0xa7, 0x42, 0xf2, 0x14,
	0x2a, 0x89, 0x9c, 0x1c, 0xa6, 0xff, 0xe6, 0x5d, 0x64, 0x69, 0x34, 0x25, 0x58, 0xbf, 0x17, 0x32,
	0x61, 0xeb, 0x4e, 0xe5, 0xeb, 0xc3, 0x55, 0x87, 0x72, 0x1c, 0x53, 0x62, 0x74, 0x5a, 0xdc, 0x63,
	0x8c, 0x3e, 0xd4, 0x7a, 0xb7, 0x23, 0x2b, 0x3a, 0xfa, 0xfc, 0xa1, 0x4e, 0xb5, 0x74, 0x12, 0xa9,
	0x07, 0xca, 0x46, 0xd7, 0x6e, 0xf8, 0xbe, 0xb8, 0x34, 0xc7, 0xae, 0x4c, 0xc7, 0xb2, 0xce, 0x68,
	0xa3, 0x6b, 0x77, 0x85, 0x0c, 0xcd, 0x51, 0x5a, 0xa5, 0x89, 0x68, 0x71, 0x80, 0xd4, 0xc8, 0x64,
	0xe6, 0x0b, 0xd9, 0xcc, 0x5b, 0x50, 0x35, 0x7f, 0x15, 0x4a, 0xce, 0x82, 0x64, 0xda, 0xcc, 0xac,
	0x25, 0x98, 0x2e, 0x53, 0xea, 0x52, 0x48, 0xd7, 0x44, 0x11, 0x63, 0x92, 0x35, 0xeb, 0x97, 0x02,
	0xdc, 0x37, 0x37, 0xc0, 0x31, 0x0b, 0x1d, 0x7d, 0x56, 0xb3, 0xd7, 0x41, 0x1c, 0x87, 0x05, 0xd5,
	0x1e, 0x3b, 0x0b, 0xf1, 0xdd, 0x31, 0x93, 0x03, 0x8f, 0xc7, 0x93, 0x68, 0x66, 0x8d, 0x7c, 0x0d,
	0xff, 0xa6, 0xc8, 0x1c, 0x33, 0x91, 0x7a, 0x67, 0x67, 0x28, 0x91, 0x3b, 0xd8, 0x3f, 0x97, 0xa8,
	0xce, 0x85, 0xef, 0xc6, 0x57, 0xc1, 0x3c, 0x88, 0xd5, 0x86, 0xcd, 0x63, 0xc6, 0x47, 0xcc, 0x9f,
	0x1a, 0x43, 0x1d, 0x48, 0x34, 0xbf, 0x61, 0x38, 0x14, 0x5e, 0x34, 0xe1, 0x26, 0x33, 0xf1, 0x14,
	0xcd, 0xce, 0x93, 0xfc, 0x5d, 0x48, 0x56, 0xa1, 0x72, 0xd2, 0x69, 0xed, 0x1f, 0xd8, 0x9d, 0xfd,
	0x56, 0xed, 0x06, 0xa9, 0x42, 0xf9, 0xb8, 0xd1, 0x6f, 0x1e, 0xd9, 0x9d, 0xc3, 0x5a, 0x81, 0x00,
	0x2c, 0x1d, 0x37, 0x3a, 0x27, 0x8d, 0x76, 0xad, 0xb8, 0xf3, 0x5d, 0xae, 0x6d, 0x92, 0x15, 0x58,
	0x3e, 0xe9, 0x7c, 0xdb, 0x79, 0xf1, 0xaa, 0x53, 0xbb, 0xa1, 0x91, 0x8d, 0x66, 0xdf, 0x7e, 0xb9,
	0x5f, 0x2b, 0x90, 0x32, 0x94, 0xec, 0x56, 0x7b, 0xbf, 0x56, 0xd4, 0xd6, 0x7a, 0xfd, 0x06, 0xed,
	0x6b, 0x6b, 0x0b, 0xa4, 0x02, 0x8b, 0xfb, 0x94, 0xbe, 0xa0, 0xb5, 0x52, 0xa4, 0x78, 0xd1, 0xed,
	0x6a, 0xc5, 0xe2, 0xee, 0x1f, 0x25, 0xa8, 0x98, 0xb0, 0x3a, 0xc2, 0x45, 0xf2, 0x29, 0x94, 0xf4,
	0x23, 0x84, 0x54, 0xeb, 0xf1, 0xdb, 0xe4, 0xa5, 0xf0, 0xdc, 0xcd, 0x3b, 0x93, 0xd5, 0x35, 0xf9,
	0x46, 0x79, 0x0c, 0x37, 0x0f, 0x31, 0xcc, 0xbc, 0x22, 0x66, 0x33, 0x33, 0xb0, 0x47, 0xb0, 0x76,
	0x88, 0xe1, 0xe4, 0x65, 0x95, 0x25, 0xae, 0x4f, 0xbd, 0xa5, 0x14, 0x79, 0x0d, 0x9b, 0xd1, 0x2c,
	0x35, 0x2d, 0x31, 0xe4, 0xa3, 0x49, 0xd6, 0xcc, 0xcc, 0x65, 0xa2, 0xca, 0xbc, 0xa3, 0xde, 0xc0,
	0xfd, 0xc8, 0xfa, 0x9c, 0x0a, 0x24, 0x0f, 0xf2, 0xb3, 0xcb, 0xbc, 0x4a, 0x9d, 0xed, 0xeb, 0x35,
	0xac, 0xf7, 0xe2, 0x1d, 0xc8, 0x75, 0x84, 0x19, 0x4d, 0x25, 0xd1, 0x6f, 0x5a, 0xf3, 0x9b, 0x8e,
	0xe9, 0x55, 0x8f, 0xe1, 0xe6, 0xc4, 0x97, 0x98, 0xdc, 0xce, 0xce, 0x4c, 0x26, 0xae, 0x27, 0x50,
	0x6b, 0x79, 0xea, 0xef, 0x50, 0x9f, 0xff, 0x0f, 0xfe, 0xe3, 0x88, 0x60, 0xf2, 0xc9, 0xac, 0x5f,
	0xbb, 0x29, 0xfa, 0x74, 0xc9, 0x3c, 0x75, 0x3f, 0xff, 0x2b, 0x00, 0x00, 0xff, 0xff, 0x64, 0x9c,
	0xc0, 0x63, 0x5d, 0x0f, 0x00, 0x00,
}
